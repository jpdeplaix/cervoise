% Cervoise's semantics after implementing effects

metavar termvar, x ::=
  {{ tex \mathit{[[termvar]]} }} {{ com  term variable  }}

metavar variant, V ::=
  {{ tex \mathit{[[variant]]} }} {{ com variant }}

metavar typvar, X ::=
  {{ tex \mathit{[[typvar]]} }} {{ com  type variable  }}

metavar exc, Exc ::=
  {{ tex \mathit{[[exc]]} }} {{ com exception }}

metavar effect, E ::=
  {{ tex \mathit{[[effect]]} }} {{ com effect }}

indexvar n ::=

grammar
  t :: 't_' ::=                                                                         {{ com term }}
    | x                                                 ::   :: Var                       {{ com variable }}
    | \ ( x : T ) -> t                                  ::   :: Lam                       {{ com abstraction }}
    | \ ( X : K ) -> t                                  ::   :: TLam                      {{ com type abstraction }}
    | \ ( E : ! ) -> t                                  ::   :: ELam                      {{ com effect abstraction }}
    | t t'                                              ::   :: App                       {{ com application }}
    | t [ T ]                                           ::   :: TApp                      {{ com type application }}
    | t [ [ eff ] ]                                     ::   :: EApp                      {{ com effect application }}
    | let x = t1 in t2                                  ::   :: Let                       {{ com let binding }}
    | let rec x : T = abs in t                          ::   :: LetRec                    {{ com recursive let binding }}
    | match t with p1 -> t1 | .. | pn -> tn end         ::   :: PatternMatching           {{ com pattern matching }}
    | ( t : T )                                         ::   :: Annot                     {{ com annotation }}
    | fail [ T ] Exc failargs                           ::   :: Fail                      {{ com fail }}
    | try t with pe1 -> t1 | .. | pen -> tn end         ::   :: Try                       {{ com try }}
    | ( t )                                             :: S :: paren
    | [ x |-> t ] t'                                    :: M :: tsub
    | [ X |-> T ] t                                     :: M :: Tsub

  v :: 'v_' ::=                                 {{ com value }}
    | x                   ::   :: Var             {{ com variable }}
    | \ ( x : T ) -> t    ::   :: Lam             {{ com abstraction }}

  abs :: 'abs_' ::=                             {{ com lambda abstractions }}
    | \ ( x : T ) -> t    ::   :: Lam             {{ com abstraction }}
    | \ ( X : K ) -> abs  ::   :: TLam            {{ com type abstraction }}
    | \ ( E : ! ) -> abs  ::   :: ELam            {{ com effect abstraction }}

  p :: 'p_' ::=                                 {{ com pattern }}
    | V patargs         ::   :: Variant           {{ com variant }}
    | x                 ::   :: Wildcard          {{ com wildcard variable }}

  pe :: 'pe_' ::=                               {{ com try pattern }}
    | Exc pateargs      ::   :: Exception         {{ com Exception pattern }}

  pateargs :: 'pateargs_' ::=                   {{ com exception patterns arguments }}
    |                   ::   :: Empty             {{ com no arguments }}
    | x1 .. xn          ::   :: Args              {{ com arguments }}

  failargs :: 'failargs_' ::=                   {{ com fail arguments }}
    |                   ::   :: Empty             {{ com no arguments }}
    | t1 .. tn          ::   :: Args              {{ com arguments }}

  patargs :: 'patargs_' ::=                   {{ com pattern arguments }}
    |                   ::   :: Empty           {{ com no arguments }}
    | p1 .. pn          ::   :: Args            {{ com arguments }}

  effelm :: 'effelm_' ::=                                       {{ com effects elements }}
    | E                                 ::   :: Effect            {{ com effect }}
    | IO                                ::   :: IOEffect          {{ com IO effect }}
    | Exn [ Exc1 | .. | Excn ]          ::   :: Exn               {{ com exception }}

  eff :: 'eff_' ::=                                             {{ com effect }}
    |                                  ::   :: EmptyEffect        {{ com empty effect }}
    | effelm1 , .. , effelmn           ::   :: Effect             {{ com effect }}

  K :: 'K_' ::=                                 {{ com kinds }}
    | *                   ::   :: Star            {{ com star }}
    | K -> K'             ::   :: KArrow          {{ com kind arrow }}

  T :: T_ ::=                                   {{ com type }}
    | X                       ::   :: var         {{ com variable }}
    | T -> T'                 ::   :: PureArrow   {{ com pure function }}
    | T -[ eff ]-> T'         ::   :: Arrow       {{ com function }}
    | \ ( X : K ) , T         ::   :: abs         {{ com operator abstraction }}
    | forall ( X : K ) , T    ::   :: forall      {{ com forall }}
    | forall ( E : ! ) , T    ::   :: EForall     {{ com effect forall }}
    | T T'                    ::   :: app         {{ com operator application }}
    | ( T )                   :: S :: paren
    | [ X |-> T ] T'          :: M :: sub

  G {{ tex \Gamma }} :: G_ ::=                  {{ com type environment }}
    | empty               ::   :: em              {{ com empty }}
    | G , x : T           ::   :: vn              {{ com vars }}
    | G , X : K           ::   :: tn              {{ com tvars }}

  terminals :: 'terminals_' ::=
    | \                   ::   :: lambda     {{ tex \lambda }}
    | -->                 ::   :: red        {{ tex \longrightarrow }}
    |  ->                 ::   :: arrow      {{ tex \rightarrow }}
    | |-                  ::   :: turnstile  {{ tex \vdash }}
    | |->                 ::   :: mapsto     {{ tex \mapsto }}
    | in                  ::   :: in         {{ tex \in }}
    | ==                  ::   :: equiv      {{ tex \equiv }}
    | !                   ::   :: phi        {{ tex \varphi }}

  formula :: 'formula_' ::=
    | judgement           ::   :: judgement
    | not ( formula )     ::   :: not
    | x = x'              ::   :: eqv
    | X == X'             ::   :: Teqv
    | x : T in G          ::   :: xTG
    | X : K in G          ::   :: XG

subrules
  v <:: t
  abs <:: t

freevars
  T X :: ftv
  t x :: fv

substitutions
  single t x :: tsubst
  single T X :: Tsubst

defns
  Jtype :: '' ::=

  defn
    G |- t : T :: :: GtT :: T_ {{ com Typing }} by

    x:T in G
    -------- :: Var
    G |- x:T

    G, x1 : T1 |- t : T
    G |- T1 : *
    ------------------------------ :: Abs
    G |- \(x1 : T1) -> t : T1 -> T

    G |- t : T1 -> T2
    G |- t' : T1
    ----------------- :: App
    G |- t t' : T2

    G, X : K |- t : T
    -------------------------------------- :: TAbs
    G |- \(X : K) -> t : forall (X : K), T

    G |- t : forall (X : K), T2
    G |- T1 : K
    --------------------------- :: TApp
    G |- t [T1] : [X |-> T1]T2

    G |- t : X
    X == X'
    G |- X' : *
    ------------ :: Eq
    G |- t : X'

    G, x : T1 |- t2 : T2
    -------------------------- :: Let
    G |- let x = t1 in t2 : T2

    G, x : T1 |- abs : T1
    G, x : T1 |- t2 : T2
    ---------------------------------- :: LetRec
    G |- let rec x : T1 = abs in t2 : T2

    % TODO: Semantics of match

    G |- t : T
    ----------- :: Annot
    G |- (t : T) : T

defns
  Jkind :: '' ::=

  defn
    G |- T : K :: :: GT :: K_ {{ com Kinding }} by

    X : K in G
    ---------- :: TVar
    G |- X : K

    G, X : K1 |- T : K2
    ------------------------------ :: Abs
    G |- \(X : K1), T : K1 -> K2

    G |- T1 : K11 -> K12
    G |- T2 : K11
    -------------------- :: App
    G |- T1 T2 : K12

    G |- T1 : *
    G |- T2 : *
    ----------------- :: Arrow
    G |- T1 -> T2 : *

    G, X : K1 |- T2 : *
    ----------------------------- :: All
    G |- forall (X : K1), T2 : *

defns
  Jequiv :: '' ::=

  defn
    T == T' :: :: ST :: Q_ {{ com Type equivalence }} by


    ------ :: Refl
    T == T

    T == T'
    ------- :: Symm
    T' == T

    T1 == T2
    T2 == T3
    -------- :: Trans
    T1 == T3

    T11 == T21
    T12 == T22
    ------------------------ :: Arrow
    T11 -> T12 == T21 -> T22

    T1 == T2
    ---------------------------------------- :: All
    forall (X : K), T1 == forall (X : K), T2

    T1 == T2
    -------------------------------- :: Abs
    \(X : K), T1 == \(X : K), T2

    T11 == T21
    T12 == T22
    ------------------ :: App
    T11 T12 == T21 T22


    ---------------------------------------- :: AppAbs
    (\(X : K), T11) T12 == [X |-> T12]T11

defns
  Jop :: '' ::=

  defn
    t --> t' ::  :: reduce :: E_ {{ com Evaluation }} by

    t1 --> t1'
    -------------- :: App1
    t1 t --> t1' t

    t1 --> t1'
    -------------- :: App2
    v t1 --> v t1'


    --------------------------------------- :: AppAbs
    (\(x : T) -> t12) v2 --> [x |-> v2]t12

    t --> t'
    ---------------- :: TApp
    t [T] --> t' [T]


    ---------------------------------- :: TAppTAbs
    (\(X : K) -> t) [T] --> [X |-> T]t

    t1 --> t1'
    -------------------------------------- :: Let1
    let x = t1 in t2 --> let x = t1' in t2

    ----------------------------- :: Let2
    let x = v in t --> [x |-> v]t


    ------------------------------------------------------------------ :: LetRec
    let rec x : T = abs in t --> [x |-> (let rec x : T = abs in abs)]t

    % TODO: Semantics of match

    t --> t'
    -------------- :: Annot
    (t : T) --> t'
