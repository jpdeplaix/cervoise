=== TODO ===

== Before the first release (0.1) ==

* Put back pure arrow checks
* Recode the typechecker !!
  * Write the semantics of System Fcω with effects, exceptions and typeclasses
    * Add a new kind for exceptions
    * Add a new kind for typeclasses (?)
    * What about a new kind for type coercions ?
    * Translate « type alias T = Unit -> T » into « type T : * » and « axiom T : T ~ (Unit -> T) »
    * Translate « exception Fail Int Float » into « type Fail : ^ » and « Fail : Int -> Float -> [^Fail^] »
    * Implement it
  * Split the part about pattern matching
  * Merge type and typevar ??
* Can we desugar typeclasses and coercion arrows to type applications like the arrow ?
* Remove PatternMatching if List.length args = 1
* Remove Rec
* Rename Gamma --> Env
* Create a new compilation phase: FirstOrderTree
  * Abs (name * {fv} * t) --> Value (fresh, Abs (name * {fv} * t))
  * Datatype [c1 .. cn] --> ConstAlloc [c1 .. cn]
  * PatternMatching --> branches + jmp + simple patterns
  * In the backend:
    * Preload all parameters/variables taken by the closure
    * Remove the gamma type
    * If fv is empty then make it constant
* Clean Printers
  * Add a printer to PretypedTree
* Fix TODOs
* Stabilization (unit-tests)
* Write the Cervoise complete semantics (pretyped-tree)
* Write down in HACKING, the syntactic sugars used in Cervoise and what they are translated to in *pure* System Fcω with effects and exceptions and typeclasses (yes, even data construtors, ...)


== Short term ==

* Prove the soundness of System Fcω using Coq
* Improve the FFI
  * Allow to pass and return abstract types
* Records
  * Mixing instances & records ?
  * Accessors ?:
    type Lol a = Lol {x : a; y : Unit}
    let lol = Lol [Unit] {x = Unit, y = Unit}
    let f () () = Unit
    let lol = f Lol#lol#x Lol#lol#y
    map (Lol#x) l
* Split parsers (Interfaces, Common, Implementation, FFI, …)
* Clean error the handling system: extend an error type (+= ..) for each module that can raise errors and print them in ErrorPrinter
* Add a builtin « fmt » operator that binds sprintf such as « fmt "%s" » has type « {Show a} => a -> String »
* Typeclasses
  * Allow tyclass constraints in classes & instances (inheritance)


== Medium term ==

* Extensible records & extensible variants
* Clean:
  * Add more explicit type names (like « type name = string » instead of just use a string)
* Handle dynamic exceptions (allocation failures, …)
    let main try with
      | CannotAllocate -> ()
    end =
      dosomething ()
  * List of dynamic exceptions (divided in categories):
    * Explicitly put exceptions by users (critical cases):
      - Assert String
      - TODO
    * Can be explicit but do we want to ?
      - DivByZero
      - NumberOverflow
    * Cannot be determined:
      - StackOverflow
      - CannotAllocate
      - Signal Int  --> We will need to remove the third argument in functions and load/store jmp-handler from a thread_local global
                        Do we really want that ? (see the OCaml interface on signals in Sys)
* Exceptions
  * Check if the exception is actually raised
* Dynamically create a wrapper when partially apply a function instead of creating a lambda for each arguments (needs an analysis)
* Add « type private T = … » to not have the getters (records) or the constructors (variants) into the environment


== Long term ==

* Pattern-matching over types
  * We could have builtin types that would tell us the current architecture for example
  * To implement that nicely we could add a new kind "Range" that we allow some types to return a range of types
* Have a real custom GC
* Type inference
* Parallelism
* Concurrency
* Implement an escape analysis
  * Avoid some dynamic allocations
  * Allow to have a fine grained effect system for references
    * Local refs don't count as IO
    * Introduce a new effect: Ref (for refs, arrays, …)
* Mutually recursive functions
* Document the different passes and optimizations
* Use LLD (still experimental) as library to avoid relying on an external tool (Clang & implicitly LD)
* Create a test tool to create correct (or incorrect) terms and check them
