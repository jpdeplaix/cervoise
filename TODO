=== TODO ===

== Short term ==

* Builtin types: Int, Float, String, Char (UTF8)
* Have a real FFI
  * let print : String -[IO]-> Unit = begin
      declare void puts(i8*)

      define print(i8* x) =
        let y = x in
        puts(y)
    end
* Change the syntax:
 * λ(a : *), T
 * {Test a Int} => T     (instead of {Test A [Int]} => T)
* « exception NotFound » creates now an abstract type of kind φ --> so remove Exn [Things]
* Add a β-reduction phase in Lambda (or after Lambda) + reduce « (λx.(λy.(f x) y)) --> f »
* Separate uppercase identifiers to be able to optimize variant calls
* Records
* Split parsers (Interfaces, Common, Implementation, FFI, …)
* Clean error the handling system: extend an error type (+= ..) for each module that can raise errors and print them in ErrorPrinter
* Add a builtin « fmt » operator that binds sprintf such as « fmt "%s" » has type « {Show a} => a -> String »


== *Stashed* ==

* Define a proper operational semantics
  * Do the semantics of Γ
* Typeclasses
 * Allow tyclass constraints in classes & instances (inheritance)
* Typeclasses (TO THINK)
 * Avoid non-equality between two types with that uses typeclasses at different places ?
 * Allow recursive use of the typeclass ?
 * Test: instance Show ({Read A} => A) = …
 * Mixing instances & records
 * Merge togather typeclasses as constraints not as type variables => Solved: {C1 A} => {C2 [A]} => T


== Medium term ==

* Extensible records & extensible variants
* Clean:
  * Fix TODO
  * Remove names in backend (« %comment = call donothing » or metadata instead) ?
  * Add functions in backend (like access_env …)
  * Add more explicit type names (like « type name = string » instead of just use a string)
* Cleaning (parser, typechecker, backend, printer, …)
* Unit-tests
* Handle dynamic exceptions (allocation failures, …)
    let main try with
      | CannotAllocate -> ()
    end =
      dosomething ()
* Exceptions
  * Check if the exception is actually raised
* Dynamically create a wrapper when partially apply a function instead of creating a lambda for each arguments (needs an analysis)
* Add « type private T = … » to not have the getters (records) or the constructors (variants) into the environment


== Long term ==

* Do we change for System Fc ? (Recursive type aliases, GADTs, …)
* Have a real custom GC
* Type inference
