import Nat
open Nat

type alias Nat = Nat.T

foreign "GC_malloc" alloc : Int -[IO]-> String

foreign "sprintf" fmt : String -> String -> Int -[IO]-> Unit

foreign "puts" println : String -[IO]-> Unit

foreign ".cervoise.add" add : Int -> Int -[IO]-> Int

let natToInt =
  let rec aux (acc : Int) (n : Nat) : IO # Int =
    match n with
    | O -> acc
    | S n -> aux (add 1 acc) n
    end
  in
  aux 0

let printNat (n : Nat) =
  let n = natToInt n in
  let buf = alloc 512 in
  fmt buf "%d" n;
  println buf

let printUnit () = println "()"

class Print a =
  let print : a -[IO]-> Unit
end

let test0 = print
let test1 ?(z : Print {a} a) = print ?[z]
let test2 ?(z : Print {a} a) (x : a) = print ?[z] x

instance [printNat] Print Unit =
  let print () = printNat O
end

instance Print Unit =
  let print = printUnit
end

class Read a =
  let read : Unit -[]-> a
end

instance Read Nat =
  let read () = O
end

let test3 () = printNat (read Unit)
let test4 () = print ?[printNat] Unit
let test5 () = print ?[Print Unit] Unit

class Fractional a(e : !) =
  let div : a -[]-> a -[e]-> a
end

exception DivByZero

instance Fractional Nat [Exn [DivByZero]] =
  let div (_ : Nat) (_ : Nat) = fail [Nat] DivByZero -- Sorry, doesn't have real ints
end

type alias T = λ(x : !), [IO, x]
type alias T1 = T [Exn [DivByZero]]
type alias T' = Nat -[T1]-> Nat

let f : T' = λ(x : Nat) -> printUnit Unit; fail [Unit] DivByZero; x

let test6 () =
  try
    printNat (div O O ?[Fractional Nat [Exn [DivByZero]]])
  with
  | DivByZero -> printUnit Unit
  end

let main =
  test0 Unit;
  test1 Unit;
  test2 Unit;
  test3 Unit;
  test4 Unit;
  test5 Unit;
  test6 Unit;
  Unit
