type Nat =
  | O
  | S Nat

let printNat : Nat -[IO]-> Nat = begin
  @msg = constant [4 x i8] c"%d\0a\00"
  declare i32 @printf(i8*, ...)
  define i8* @SystemFOmega..printNat(i8* %i) {
    %access_prim = load i8* %i
    %access = zext i8 %access_prim to i32
    call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @msg, i32 0, i32 0), i32 %access)
    ret i8* %i
  }
end

let id X (x:X) (x:X) = x

let test = id [Nat]

let testdeux (x : Nat) = printNat (test O O)

type alias Id = λX, X

type alias I = Id

type alias Ip = Id

type alias II = Ip Nat

type Pair X Y = Pair X Y

let test = Pair [Nat] [Nat] O O

let test = match test with
  | Pair O O -> Unit
  | x -> Unit
  end

--type alias Test = λX, λX, X

let rec recursiveFun (x : Nat) (y : Nat) : [[IO]] Nat =
  recursiveFun y (printNat x)

let main =
  let testdeux = testdeux O in
  let testa = recursiveFun O (S O) in
  Unit
