=== TODO ===

== Before the first release (0.1) ==

* Replace COPYING headers by a link to the LICENSE file
* Fix typing (debunijn ?)
* Rename Lambda.used_vars to Lambda.free_vars
* Cleans
  * pre-typing
  * Fix TODO
* Stabilization (unit-tests)
* Define a proper operational semantics
  * Do the semantics of Γ
  * Do the semantics of typeclasses


== Short term ==

* Improve the FFI
  * Allow to pass and return abstract types
* « exception NotFound » creates now an abstract type of kind φ --> so remove Exn [Things]
* Records
  * Mixing instances & records ?
  * Accessors ?:
    type Lol a = Lol {x : a; y : Unit}
    let lol = Lol [Unit] {x = Unit, y = Unit}
    let f () () = Unit
    let lol = f Lol#lol#x Lol#lol#y
    map (Lol#x) l
* Split parsers (Interfaces, Common, Implementation, FFI, …)
* Clean error the handling system: extend an error type (+= ..) for each module that can raise errors and print them in ErrorPrinter
* Add a builtin « fmt » operator that binds sprintf such as « fmt "%s" » has type « {Show a} => a -> String »
* Typeclasses
  * Allow tyclass constraints in classes & instances (inheritance)


== Medium term ==

* Extensible records & extensible variants
* Clean:
  * Add more explicit type names (like « type name = string » instead of just use a string)
* Handle dynamic exceptions (allocation failures, …)
    let main try with
      | CannotAllocate -> ()
    end =
      dosomething ()
  * List of dynamic exceptions (divided in categories):
    * Explicitly put exceptions by users (critical cases):
      - Assert String
      - TODO
    * Can be explicit but do we want to ?
      - DivByZero
      - NumberOverflow
    * Cannot be determined:
      - StackOverflow
      - CannotAllocate
      - Signal Int  --> We will need to remove the third argument in functions and load/store jmp-handler from a thread_local global
                        Do we really want that ? (see the OCaml interface on signals in Sys)
* Exceptions
  * Check if the exception is actually raised
* Dynamically create a wrapper when partially apply a function instead of creating a lambda for each arguments (needs an analysis)
* Add « type private T = … » to not have the getters (records) or the constructors (variants) into the environment


== Long term ==

* Do we change for System Fc ? (Recursive type aliases, GADTs, …)
* Have a real custom GC
* Type inference
* Parallelism
* Concurrency
* Implement an escape analysis
  * Avoid some dynamic allocations
  * Allow to have a fine grained effect system for references
    * Local refs don't count as IO
    * Introduce a new effect: Ref (for refs, arrays, …)
* Mutually recursive functions
* Prove the type system correct
* Document the different passes and optimizations
* Use LLD (still experimental) as library to avoid relying on an external tool (Clang & implicitly LD)
* Create a test tool to create correct (or incorrect) terms and check them
