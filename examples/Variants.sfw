type Nat =
  | O
  | S Nat
  | D Nat Nat

let printZero : Unit -[IO]-> Unit = begin
  @msg = constant [3 x i8] c"0\0a\00"

  declare i32 @printf(i8*, ...)

  define i8* @Variants..printZero(i8*) {
    %r1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([3 x i8]* @msg, i32 0, i32 0))
    %r = inttoptr i32 %r1 to i8*
    ret i8* %r
  }
end

let printOne : Unit -[IO]-> Unit = begin
  @msg = constant [3 x i8] c"1\0a\00"

  declare i32 @printf(i8*, ...)

  define i8* @Variants..printOne(i8*) {
    %r1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([3 x i8]* @msg, i32 0, i32 0))
    %r = inttoptr i32 %r1 to i8*
    ret i8* %r
  }
end

let printTwo : Unit -[IO]-> Unit = begin
  @msg = constant [3 x i8] c"2\0a\00"

  declare i32 @printf(i8*, ...)

  define i8* @Variants..printTwo(i8*) {
    %r1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([3 x i8]* @msg, i32 0, i32 0))
    %r = inttoptr i32 %r1 to i8*
    ret i8* %r
  }
end

let printOther : Unit -[IO]-> Unit = begin
  @msg = constant [7 x i8] c"other\0a\00"

  declare i32 @printf(i8*, ...)

  define i8* @Variants..printOther(i8*) {
    %r1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([7 x i8]* @msg, i32 0, i32 0))
    %r = inttoptr i32 %r1 to i8*
    ret i8* %r
  }
end

let rec f (x : Nat) : [IO] Nat =
  match x with
  | O -> let lol = printZero Unit in O
  | S O -> let lol = printOne Unit in O
  | S (S O) -> let lol = printTwo Unit in O
  | S (S (S O)) -> let lol = printZero Unit in O
  | S (S (S a)) -> let lol = printOther Unit in a
  | D a b -> f b
  | a -> a
  end

let main =
  let test = f O in
  let test = f (S O) in
  let test = f (S (S O)) in
  let test = f (S (S (S O))) in
  let test = f (S (S (S (S O)))) in
  let test = f (S (S (S (S (S O))))) in
  let test = f (S (S (S (S (S (S O)))))) in
  let test = f (D (S O) O) in
  let test = f (D O (S O)) in
  Unit
