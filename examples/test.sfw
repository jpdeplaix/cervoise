type Int =
  | O : Int
  | S : Int -> Int

let printInt : Int -> Int = begin
  @msg = constant [4 x i8] c"%d\0a\00"
  declare i32 @printf(i8*, ...)
  define i8* @.printInt(i8* %i) {
    %access_prim = load i8* %i
    %access = zext i8 %access_prim to i32
    %r1 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @msg, i32 0, i32 0), i32 %access)
    %r = inttoptr i32 %r1 to i8*
    ret i8* %r
  }
end

let zero : Int = begin
  @.zero = constant i8 0
end

let app (x:Int->Int) (f:Int->Int->Int) = f

let id (x:Int) = x
let const (x:Int) (y:Int) = x

let curry = app id

let test = curry const

let segfault = printInt (test zero zero)
