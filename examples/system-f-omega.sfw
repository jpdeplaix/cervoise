type Int =
  | O : Int
  | S : Int -> Int

let printInt : Int -> Int = begin
  @msg = internal constant [4 x i8] c"%d\0a\00"
  declare i32 @printf(i8*, ...)
  define i8* @__printInt(i8* %i, i8**) {
    %access_prim = load i8* %i
    %access = zext i8 %access_prim to i32
    call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @msg, i32 0, i32 0), i32 %access)
    ret i8* %i
  }
  @_printInt = global {i8* (i8*, i8**)*, i8**} {i8* (i8*, i8**)* @__printInt, i8** null}
  @printInt = global {i8* (i8*, i8**)*, i8**}* getelementptr({i8* (i8*, i8**)*, i8**}* @_printInt)
end

let id X (x:X) (x:X) = x

let test = id [Int]

let testdeux = printInt (test O O)

type alias Id = Î»X, X

type alias I = Id

type alias Ip = Id

type alias II = Ip Int

type Pair : * -> * -> * = Pair : forall X Y, X -> Y -> Pair X Y

let test = Pair [Int] [Int] O O

let rec recursiveFun (x : Int) (y : Int) : Int =
  recursiveFun y (printInt x)

let testa = recursiveFun O (S O)
