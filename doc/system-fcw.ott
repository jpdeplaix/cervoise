% System FcÏ‰

metavar x ::=                     {{ com term variable }}
metavar a {{ tex \alpha }} ::=    {{ com type variable }}
metavar X {{ tex T }} ::=         {{ com type }}
metavar c ::=                     {{ com coercion variable }}

grammar
  t :: t_ ::=                                                            {{ com term }}
    | x                                          ::   :: Var               {{ com variable }}
    | \ ( x : T ) => t                           ::   :: Abs               {{ com abstraction }}
    | \ { a : K } => t                           ::   :: TAbs              {{ com type abstraction }}
    | \ { c : T1 ~ T2 } => t                     ::   :: CAbs              {{ com coercion abstraction }}
    | t1 t2                                      ::   :: App               {{ com application }}
    | t [ T ]                                    ::   :: TApp              {{ com type application }}
    | t ~[ C ]                                   ::   :: CApp              {{ com coercion application }}
    | t : T                                      ::   :: Annot             {{ com type annotation }}
    | t :> C                                     ::   :: Coerce            {{ com coercion }}
    | ( t )                                      :: S :: Paren             {{ com parenthesis }}

  v :: v_ ::=                                                            {{ com value }}
    | \ ( x : T ) => t                           ::   :: Lam               {{ com abstraction }}

  K {{ tex \kappa }} :: K_ ::=                                           {{ com kind }}
    | *                                          ::   :: Star              {{ com star }}
    | K1 -> K2                                   ::   :: KArrow            {{ com kind arrow }}
    | ( K )                                      :: S :: Paren             {{ com parenthesis }}

  T {{ tex \tau }} :: T_ ::=                                             {{ com type }}
    | a                                          ::   :: var               {{ com type variable }}
    | X                                          ::   :: type              {{ com type }}
    | T1 -> T2                                   ::   :: arrow             {{ com arrow }}
    | { T1 ~ T2 } -> T3                          ::   :: carrow            {{ com coercion arrow }}
    | \ ( a : K ) , T                            ::   :: abs               {{ com operator abstraction }}
    | forall ( a : K ) , T                       ::   :: forall            {{ com forall }}
    | T1 T2                                      ::   :: app               {{ com operator application }}
    | ( T )                                      :: S :: paren             {{ com parenthesis }}

  C {{ tex \gamma }} :: C_ ::=                                           {{ com coercion proof term }}
    | c                                          ::   :: var               {{ com variable }}
    | refl T                                     ::   :: refl              {{ com reflexivity }}
    | sym C                                      ::   :: sym               {{ com symmetry }}
    | C1 . C2                                    ::   :: comp              {{ com composition }}
    | C1 -> C2                                   ::   :: arrow             {{ com arrow introduction }}
    | { T1 ~ T2 } -> C                           ::   :: carrow            {{ com coercion arrow introduction }}
    | \ ( a : K ) , C                            ::   :: abs               {{ com operator abstraction introduction }}
    | forall ( a : K ) , C                       ::   :: forall            {{ com forall introduction }}
    | C1 C2                                      ::   :: app               {{ com application introduction }}
    | left C                                     ::   :: cleft             {{ com left elimination }}
    | right C                                    ::   :: cright            {{ com right elimination }}
    | ( C )                                      :: S :: paren             {{ com parenthesis }}

  G {{ tex \Gamma }} :: G_ ::=                                           {{ com typing environment }}
    | empty                                      ::   :: empty             {{ com empty }}
    | G , x : T                                  ::   :: var               {{ com variable }}
    | G , X : K                                  ::   :: type              {{ com abstract type }}
    | G , a : K                                  ::   :: tyvar             {{ com type variable }}
    | G , c : T1 ~ T2                            ::   :: cvar              {{ com coercion variable }}

% Ott meta rules

  terminals :: terminals_ ::=
    | .                   ::   :: comp       {{ tex \circ }}
    | ~                   ::   :: tilde      {{ tex \sim }}
    | \                   ::   :: lambda     {{ tex \lambda }}
    | -->                 ::   :: red        {{ tex \longrightarrow }}
    | =>                  ::   :: earrow     {{ tex \Rightarrow }}
    | ->                  ::   :: arrow      {{ tex \rightarrow }}
    | |-                  ::   :: turnstile  {{ tex \vdash }}
    | |->                 ::   :: mapsto     {{ tex \mapsto }}
    | |>                  ::   :: rhd        {{ tex \rhd }}
    | :>                  ::   :: coerce     {{ tex \blacktriangleright }}
    | ==                  ::   :: equiv      {{ tex \equiv }}
    | ~[                  ::   :: tildeL     {{ tex ~{\sim}[ }}
    | [                   ::   :: bracket    {{ tex ~[ }}
    | isin                ::   :: isin       {{ tex \in }}
    | notin               ::   :: notin      {{ tex \notin }}
    | forall              ::   :: forall     {{ tex \forall }}
    | empty               ::   :: empty      {{ tex \emptyset }}

  formula :: formula_ ::=
    | judgement           ::   :: judgement
    | x : T isin G        ::   :: xIsInG
    | X : K isin G        ::   :: XIsInG
    | a : K isin G        ::   :: aIsInG
    | c : T1 ~ T2 isin G  ::   :: cIsInG
    | a notin G           ::   :: aNotInG

subrules
  v <:: t

% Semantics

defns
  JSubstT :: '' ::=

  defn
    [ a |-> T1 ] T2 |> T3 :: :: SubstT :: SubstT_ {{ com Type substitution }} by


    ---------------- :: Var1
    [a |-> T] a |> T


    ------------------- :: Var2
    [a1 |-> T] a2 |> a2


    ---------------- :: Type
    [a |-> T] X |> X

    [a |-> T1] T2 |> T2'
    [a |-> T1] T3 |> T3'
    --------------------------------- :: Arrow
    [a |-> T1] T2 -> T3 |> T2' -> T3'

    [a |-> T1] T2 |> T2'
    [a |-> T1] T3 |> T3'
    [a |-> T1] T4 |> T4'
    ------------------------------------------------ :: CArrow
    [a |-> T1] {T2 ~ T3} -> T4 |> {T2' ~ T3'} -> T4'


    --------------------------------------- :: Abs1
    [a |-> T1] \(a : K), T2 |> \(a : K), T2

    [a1 |-> T1] T2 |> T2'
    ------------------------------------------- :: Abs2
    [a1 |-> T1] \(a2 : K), T2 |> \(a2 : K), T2'


    --------------------------------------------------- :: Forall1
    [a |-> T1] forall (a : K), T2 |> forall (a : K), T2

    [a1 |-> T1] T2 |> T2'
    ------------------------------------------------------- :: Forall2
    [a1 |-> T1] forall (a2 : K), T2 |> forall (a2 : K), T2'

    [a |-> T1] T2 |> T2'
    [a |-> T1] T3 |> T3'
    --------------------------- :: App
    [a |-> T1] T2 T3 |> T2' T3'

defns
  Jtype :: '' ::=

  defn
    G |- t : T :: :: GtT :: T_ {{ com Typing rules }} by

    x : T isin G
    ------------ :: Var
    G |- x : T

    G, x : T1 |- t : T2
    G |- T1 : *
    ------------------------------ :: Abs
    G |- \(x : T1) => t : T1 -> T2

    G, a : K |- t : T
    a notin G
    -------------------------------------- :: TyAbs
    G |- \{a : K} => t : forall (a : K), T

    G, c : T1 ~ T2 |- t : T3
    G |- T1 : K
    G |- T2 : K
    ------------------------------------------ :: CAbs
    G |- \{c : T1 ~ T2} => t : {T1 ~ T2} -> T3

    G |- t1 : T2 -> T1
    T2 == T2'
    G |- t2 : T2'
    ------------------ :: App
    G |- t1 t2 : T1

    G |- t : forall (a : K), T2
    G |- T1 : K
    [a |-> T1] T2 |> T2'
    --------------------------- :: TyApp
    G |- t [T1] : T2'

    G |- t : {T1 ~ T2} -> T3
    T1 == T1'
    T2 == T2'
    G |- C : T1' ~ T2'
    ------------------------ :: CApp
    G |- t ~[C] : T3

    G |- t : T2
    T1 == T2
    ------------------ :: Annot
    G |- (t : T1) : T1

    G |- C : T1 ~ T2
    T1 == T1'
    G |- t : T1'
    ---------------- :: Coerce
    G |- t :> C : T2

defns
  JCoerce :: '' ::=

  defn
    G |- C : T1 ~ T2 :: :: GC :: C_ {{ com Coercion typing }} by

    c : T1 ~ T2 isin G
    ------------------ :: Var
    G |- c : T1 ~ T2


    ------------------- :: Refl
    G |- refl T : T ~ T

    G |- C : T2 ~ T1
    -------------------- :: Sym
    G |- sym C : T1 ~ T2

    G |- C1 : T1 ~ T2
    T2 == T2'
    G |- C2 : T2' ~ T3
    ---------------------- :: Comp
    G |- C1 . C2 : T1 ~ T3

    G |- C1 : T1 ~ T1'
    G |- C2 : T2 ~ T2'
    G |- T1 : *
    G |- T2 : *
    ------------------------------------- :: Arrow
    G |- C1 -> C2 : T1 -> T2 ~ T1' -> T2'

    G |- T1 : K
    G |- T2 : K
    G |- T3 : *
    G |- C : T3 ~ T3'
    -------------------------------------------------------- :: CArrow
    G |- {T1 ~ T2} -> C : {T1 ~ T2} -> T3 ~ {T1 ~ T2} -> T3'

    G, a : K |- C : T1 ~ T2
    ---------------------------------------------- :: Abs
    G |- \(a : K), C : \(a : K), T1 ~ \(a : K), T2

    G |- T1 : *
    G, a : K |- C : T1 ~ T2
    ---------------------------------------------------------------- :: Forall
    G |- forall (a : K), C : forall (a : K), T1 ~ forall (a : K), T2

    G |- C1 : T1 ~ T1'
    G |- C2 : T2 ~ T2'
    G |- T1 : K2 -> K1
    G |- T2 : K2
    ----------------------------------- :: App
    G |- C1 C2 : T1 T2 ~ T1' T2'

    G |- C : T1 -> T2 ~ T1' -> T2'
    ----------------------------------- :: Left1
    G |- left C : T1 ~ T1'

    G |- C : T1 T2 ~ T1' T2'
    ----------------------------------- :: Left2
    G |- left C : T1 ~ T1'

    G |- C : T1 -> T2 ~ T1' -> T2'
    ----------------------------------- :: Right1
    G |- right C : T2 ~ T2'

    G |- C : {T1 ~ T2} -> T3 ~ {T1' ~ T2'} -> T3'
    T1 == T1'
    T2 == T2'
    --------------------------------------------- :: Right2
    G |- right C : T3 ~ T3'

    G |- C : T1 T2 ~ T1' T2'
    ----------------------------------- :: Right3
    G |- right C : T2 ~ T2'

defns
  Jkind :: '' ::=

  defn
    G |- T : K :: :: GT :: K_ {{ com Kinding }} by

    a : K isin G
    ------------ :: Var
    G |- a : K

    X : K isin G
    ------------ :: AbsType
    G |- X : K

    G, a : K1 |- T : K2
    ---------------------------- :: Abs
    G |- \(a : K1), T : K1 -> K2

    G |- T1 : K2 -> K1
    G |- T2 : K2
    ------------------ :: App
    G |- T1 T2 : K1

    G |- T1 : *
    G |- T2 : *
    ----------------- :: Arrow
    G |- T1 -> T2 : *

    G |- T1 : K
    G |- T2 : K
    G |- T3 : *
    ------------------------ :: CArrow
    G |- {T1 ~ T2} -> T3 : *

    G, a : K |- T : *
    -------------------------- :: Forall
    G |- forall (a : K), T : *

defns
  Jequiv :: '' ::=

  defn
    T1 == T2 :: :: ST :: EQ_ {{ com Type equivalence }} by


    ------ :: Refl
    T == T

    T2 == T1
    -------- :: Symm
    T1 == T2

    T1 == T2
    T2 == T3
    -------- :: Trans
    T1 == T3


    ------ :: Var
    a == a


    ------ :: AbsType
    X == X

    T1 == T1'
    T2 == T2'
    ---------------------- :: Arrow
    T1 -> T2 == T1' -> T2'

    T1 == T1'
    T2 == T2'
    T3 == T3'
    ------------------------------------- :: CArrow
    {T1 ~ T2} -> T3 == {T1' ~ T2'} -> T3'

    T1 == T2
    ---------------------------------------- :: Forall
    forall (a : K), T1 == forall (a : K), T2

    T1 == T2
    ---------------------------- :: Abs
    \(a : K), T1 == \(a : K), T2

    T1 == T1'
    T2 == T2'
    ---------------- :: App
    T1 T2 == T1' T2'

    [a |-> T2] T1 |> T1'
    ------------------------ :: AppAbs
    (\(a : K), T1) T2 == T1'

defns
  JSubst :: '' ::=

  defn
    [ x |-> v ] t1 |> t2 :: :: Subst :: Subst_ {{ com substitution }} by


    ---------------- :: Var1
    [x |-> v] x |> v


    ------------------- :: Var2
    [x1 |-> v] x2 |> x2


    ---------------------------------------- :: Abs1
    [x |-> v] \(x : T) => t |> \(x : T) => t

    [x1 |-> v] t1 |> t2
    --------------------------------------------- :: Abs2
    [x1 |-> v] \(x2 : T) => t1 |> \(x2 : T) => t2

    [x |-> v] t1 |> t2
    ------------------------------------------ :: TAbs
    [x |-> v] \{a : K} => t1 |> \{a : K} => t2

    [x |-> v] t1 |> t2
    ------------------------------------------------------ :: CAbs
    [x |-> v] \{c : T1 ~ T2} => t1 |> \{c : T1 ~ T2} => t2

    [x |-> v] t1 |> t1'
    [x |-> v] t2 |> t2'
    -------------------------- :: App
    [x |-> v] t1 t2 |> t1' t2'

    [x |-> v] t1 |> t2
    -------------------------- :: TApp
    [x |-> v] t1 [T] |> t2 [T]

    [x |-> v] t1 |> t2
    ---------------------------- :: CApp
    [x |-> v] t1 ~[C] |> t2 ~[C]

    [x |-> v] t1 |> t2
    -------------------------- :: Annot
    [x |-> v] t1 : T |> t2 : T

    [x |-> v] t1 |> t2
    ---------------------------- :: Coerce
    [x |-> v] t1 :> C |> t2 :> C

defns
  Jop :: '' ::=

  defn
    t1 --> t2 ::  :: reduce :: E_ {{ com Evaluation }} by

    t2 --> t2'
    ---------------- :: App1
    t1 t2 --> t1 t2'

    t1 --> t1'
    -------------- :: App2
    t1 v --> t1' v

    [x |-> v] t |> t'
    t' --> t''
    ------------------------- :: AppAbs
    (\(x : T) => t) v --> t''

    t --> t'
    -------------------- :: TAbs
    \{a : K} => t --> t'

    t --> t'
    -------------------------- :: CAbs
    \{c : T1 ~ T2} => t --> t'

    t --> t'
    ------------ :: TApp
    t [T] --> t'

    t --> t'
    ------------- :: CApp
    t ~[C] --> t'

    t --> t'
    ------------ :: Annot
    t : T --> t'

    t --> t'
    ------------- :: Coerce
    t :> C --> t'
